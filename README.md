# Chain Transaction Solver using LLMs and Knowledge Graphs

This application was developed to solve **Chain Transaction (CT) cases** under **Austrian tax law** using **Large Language Models (LLMs)** and **Knowledge Graphs (KGs)**.

The tool extracts knowledge from natural language text, generates a knowledge graph in **Neo4j Aura**, runs a set of predefined **Cypher queries**, and applies **logic-based rules** to identify the **movable supply** in chain transactions.

---

## 🧠 Key Technologies

- **Large Language Models (LLMs)** via Langsmith
- **Neo4j Aura** for knowledge graph storage and querying
- **Python** for orchestration and logic rules
- **Cypher** query language for graph processing

---

## 🚀 Getting Started

### 1. Installation

Clone the repository and install the dependencies:

```bash
pip install -r requirements.txt
```

### 2. Setup

- Ensure that your **Neo4j Aura instance is running**.
- Create a `.env` file in the root directory with the correct credentials for:
  - Neo4j Aura
  - Langsmith

### 3. Files Overview

- `run_experiment.py`  
  Connects to the LLM via Langsmith and generates Cypher statements.

- `ct_solver.py`  
  Processes LLM output, builds the knowledge graph, applies logic rules, and identifies the movable supply.

---

## ⚙️ Core Functions

### `apply_logic_based_rules(graph, df)`
- Runs queries and applies logic to:
  1. Identify and extract key data.
  2. Check if a valid chain transaction exists.
  3. Determine the movable supply.

### `build_graph(query)`
- Executes Cypher statements to build the KG in Neo4j.

### `clean_statement(statement)`
- Cleans LLM-generated Cypher statements to remove inconsistencies.

### `delete_graph()`
- Deletes the current graph from the Neo4j database.

### `replace_name_fields(text)`
- Normalizes entity names to ensure consistency.

### `visualize_graph(graph, tv_name, id_internal, example_name)`
- Custom visualization of the graph and the identified movable supply.

---

## 🧾 Key Cypher Queries

```python
query_last_enterprise = """
OPTIONAL MATCH (n:Unternehmen)-[:BESTELLUNG]->() 
WHERE NOT n:Transportverantwortung AND NOT EXISTS { MATCH ()-[:BESTELLUNG]->(n) } 
RETURN COALESCE(n, "Inconsistent, no solution.") AS result
"""

query_first_enterprise = """
OPTIONAL MATCH ()-[:BESTELLUNG]->(n:Unternehmen)
WHERE NOT n:Transportverantwortung AND NOT EXISTS { MATCH (n)-[:BESTELLUNG]->() } 
RETURN COALESCE(n, "Inconsistent, no solution.") AS result
"""

query_find_transport_of_goods = """
OPTIONAL MATCH (n:Unternehmen)-[:WARENBEWEGUNG]->(m:Unternehmen) 
RETURN n, 'WARENBEWEGUNG' as Info, m
"""

query_find_dispatch_country = """
OPTIONAL MATCH (n:Unternehmen)-[:WARENBEWEGUNG]->(m:Unternehmen) 
RETURN n.Sitz
"""

query_transport_responsibility = """
MATCH (n:Unternehmen)-[:HAT]->(:Transportverantwortung)
RETURN n
"""

query_no_of_products = """
MATCH ()-[r]->()
WHERE type(r) IN ['BESTELLUNG', 'WARENBEWEGUNG']
RETURN count(DISTINCT r.Produkt) AS no_of_products
"""

query_no_of_orders = "MATCH (:Unternehmen)-[r:BESTELLUNG]->(:Unternehmen) RETURN count(r) AS no_of_orders"
query_no_of_enterprises = "MATCH (n:Unternehmen) RETURN count(n) AS no_of_enterprises"
query_no_of_transports_of_goods = "MATCH (:Unternehmen)-[r:WARENBEWEGUNG]->(:Unternehmen) RETURN count(r) AS no_of_transports_of_goods"
query_no_of_tr = "MATCH (:Unternehmen)-[r:HAT]-(:Transportverantwortung) RETURN count(r) AS no_of_tr"

query_first_supply = f"""
OPTIONAL MATCH (n:Unternehmen)-[:BESTELLUNG]->(m:Unternehmen {{Name: "{first_enterprise_name}"}})
RETURN n, 'BESTELLUNG' as Info, m
"""

query_last_supply = f"""
OPTIONAL MATCH (n:Unternehmen {{Name: "{last_enterprise_name}"}})-[:BESTELLUNG]->(m:Unternehmen)
RETURN n, 'BESTELLUNG' as Info, m
"""

query_intermediate_supply = f"""
OPTIONAL MATCH (n:Unternehmen)-[:BESTELLUNG]->(m:Unternehmen {{Name: "{tr_name}"}})
RETURN n, 'BESTELLUNG' as Info, m
"""

query_pre_intermediate_supply = f"""
OPTIONAL MATCH (n:Unternehmen {{Name: "{tr_name}"}})-[:BESTELLUNG]->(m:Unternehmen)
RETURN n, 'BESTELLUNG' as Info, m
"""

query_movable_supply = (f'\nMATCH (a:Unternehmen {{Name: "{start}"}}),'
                        f'(b:Unternehmen {{Name: "{ziel}"}})'
                        '\nCREATE (a)-[:BEWEGTE_LIEFERUNG]->(b)')
```
---

## 📊 Data Processing Pipeline

1. Load a `.csv` file generated by the LLM application (Langsmith).
2. Merge with stored case database using IDs.
3. Initialize Neo4j connection and build the graph.
4. Apply logic rules to detect chain transaction patterns.
5. Compare identified movable supply with sample solution:
   - If it matches → `correct`
   - If not → `check manually` 
6. Visualize the knowledge graph.

---

## 🛠 Exception Handling

All exceptions are logged with the following information:

- Exception type
- File name
- Line number
- Error message

---

## 📬 Contact

For questions or contributions, please contact:  
📧 knogler.lukas@gmail.com

---

## 📚 Related Work

This repository is part of the research project:

**Using Large Language Models and Knowledge Graphs for Deciding VAT Chain-Transaction Cases in Austrian Tax Law**  
*Author: Lukas Knogler, Austria (JKU Linz)*  
See the [experimental results repository](https://github.com/knolukas/ct-solver-results.git) for more.
